/* !
 * MotionPathPlugin 3.12.2
 * https://greensock.com
 *
 * @license Copyright 2023, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */

!function(t, e) {
'object'==typeof exports&&'undefined'!=typeof module?e(exports):'function'==typeof define&&define.amd?define(['exports'], e):e((t=t||self).window=t.window||{});
}(this, function(t) {
  'use strict'; function p(t) {
    return 'string'==typeof t;
  } function x(t) {
    return Math.round(1e10*t)/1e10||0;
  } function y(t, e, n, r) {
    const a=t[e]; const o=1===r?6:subdivideSegment(a, n, r); if (o&&o+n+2<a.length) return t.splice(e, 0, a.slice(0, n+o+2)), a.splice(0, n+o), 1;
  } function C(t, e) {
    let n=t.length; const r=t[n-1]||[]; const a=r.length; n&&e[0]===r[a-2]&&e[1]===r[a-1]&&(e=r.concat(e.slice(2)), n--), t[n]=e;
  } const M=/[achlmqstvz]|(-?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi; const T=/(?:(-)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi; const L=/[\+\-]?\d*\.?\d+e[\+\-]?\d+/gi; const r=/(^[#\.][a-z]|[a-y][a-z])/i; const V=Math.PI/180; const s=180/Math.PI; const F=Math.sin; const U=Math.cos; const H=Math.abs; const $=Math.sqrt; const l=Math.atan2; const A=1e8; const h=function _isNumber(t) {
    return 'number'==typeof t;
  }; const S={}; const _={}; const e=1e5; const d=function _wrapProgress(t) {
    return Math.round((t+A)%1*e)/e||(t<0?0:1);
  }; const N=function _round(t) {
    return Math.round(t*e)/e||0;
  }; const m=function _getSampleIndex(t, e, n) {
    const r=t.length; let a=~~(n*r); if (t[a]>e) {
      for (;--a&&t[a]>e;);a<0&&(a=0);
    } else for (;t[++a]<e&&a<r;);return a<r?a:r-1;
  }; const O=function _copyMetaData(t, e) {
    return e.totalLength=t.totalLength, t.samples?(e.samples=t.samples.slice(0), e.lookup=t.lookup.slice(0), e.minLength=t.minLength, e.resolution=t.resolution):t.totalPoints&&(e.totalPoints=t.totalPoints), e;
  }; function getRawPath(t) {
    let e; const n=(t=p(t)&&r.test(t)&&document.querySelector(t)||t).getAttribute?t:0; return n&&(t=t.getAttribute('d'))?(n._gsPath||(n._gsPath={}), (e=n._gsPath[t])&&!e._dirty?e:n._gsPath[t]=stringToRawPath(t)):t?p(t)?stringToRawPath(t):h(t[0])?[t]:t:console.warn('Expecting a <path> element or an SVG path data string');
  } function reverseSegment(t) {
    let e; let n=0; for (t.reverse(); n<t.length; n+=2)e=t[n], t[n]=t[n+1], t[n+1]=e; t.reversed=!t.reversed;
  } const B={rect: 'rx,ry,x,y,width,height', circle: 'r,cx,cy', ellipse: 'rx,ry,cx,cy', line: 'x1,x2,y1,y2'}; function convertToPath(t, e) {
    let n; let r; let a; let o; let i; let s; let l; let h; let u; let g; let f; let c; let p; let d; let m; let v; let y; let x; let w; let P; let b; let M; const R=t.tagName.toLowerCase(); const L=.552284749831; return 'path'!==R&&t.getBBox?(s=function _createPath(t, e) {
      let n; const r=document.createElementNS('http://www.w3.org/2000/svg', 'path'); const a=[].slice.call(t.attributes); let o=a.length; for (e=','+e+','; -1<--o;)n=a[o].nodeName.toLowerCase(), e.indexOf(','+n+',')<0&&r.setAttributeNS(null, n, a[o].nodeValue); return r;
    }(t, 'x,y,width,height,cx,cy,rx,ry,r,x1,x2,y1,y2,points'), M=function _attrToObj(t, e) {
      for (var n=e?e.split(','):[], r={}, a=n.length; -1<--a;)r[n[a]]=+t.getAttribute(n[a])||0; return r;
    }(t, B[R]), 'rect'===R?(o=M.rx, i=M.ry||o, r=M.x, a=M.y, g=M.width-2*o, f=M.height-2*i, n=o||i?'M'+(v=(d=(p=r+o)+g)+o)+','+(x=a+i)+' V'+(w=x+f)+' C'+[v, P=w+i*L, m=d+o*L, b=w+i, d, b, d-(d-p)/3, b, p+(d-p)/3, b, p, b, c=r+o*(1-L), b, r, P, r, w, r, w-(w-x)/3, r, x+(w-x)/3, r, x, r, y=a+i*(1-L), c, a, p, a, p+(d-p)/3, a, d-(d-p)/3, a, d, a, m, a, v, y, v, x].join(',')+'z':'M'+(r+g)+','+a+' v'+f+' h'+-g+' v'+-f+' h'+g+'z'):'circle'===R||'ellipse'===R?(h='circle'===R?(o=i=M.r)*L:(o=M.rx, (i=M.ry)*L), n='M'+((r=M.cx)+o)+','+(a=M.cy)+' C'+[r+o, a+h, r+(l=o*L), a+i, r, a+i, r-l, a+i, r-o, a+h, r-o, a, r-o, a-h, r-l, a-i, r, a-i, r+l, a-i, r+o, a-h, r+o, a].join(',')+'z'):'line'===R?n='M'+M.x1+','+M.y1+' L'+M.x2+','+M.y2:'polyline'!==R&&'polygon'!==R||(n='M'+(r=(u=(t.getAttribute('points')+'').match(T)||[]).shift())+','+(a=u.shift())+' L'+u.join(','), 'polygon'===R&&(n+=','+r+','+a+'z')), s.setAttribute('d', rawPathToString(s._gsRawPath=stringToRawPath(n))), e&&t.parentNode&&(t.parentNode.insertBefore(s, t), t.parentNode.removeChild(t)), s):t;
  } function getRotationAtBezierT(t, e, n) {
    let r; let a=t[e]; let o=t[e+2]; let i=t[e+4]; return a+=(o-a)*n, a+=((o+=(i-o)*n)-a)*n, r=o+(i+(t[e+6]-i)*n-o)*n-a, a=t[e+1], a+=((o=t[e+3])-a)*n, a+=((o+=((i=t[e+5])-o)*n)-a)*n, N(l(o+(i+(t[e+7]-i)*n-o)*n-a, r)*s);
  } function sliceRawPath(t, e, n) {
    n=function _isUndefined(t) {
      return void 0===t;
    }(n)?1:x(n)||0, e=x(e)||0; const r=Math.max(0, ~~(H(n-e)-1e-8)); let a=function copyRawPath(t) {
      for (var e=[], n=0; n<t.length; n++)e[n]=O(t[n], t[n].slice(0)); return O(t, e);
    }(t); if (n<e&&(e=1-e, n=1-n, function _reverseRawPath(t, e) {
      let n=t.length; for (e||t.reverse(); n--;)t[n].reversed||reverseSegment(t[n]);
    }(a), a.totalLength=0), e<0||n<0) {
      const o=Math.abs(~~Math.min(e, n))+1; e+=o, n+=o;
    }a.totalLength||cacheRawPathMeasurements(a); let i; let s; let l; let h; let u; let g; let f; let c; const p=1<n; let d=getProgressData(a, e, S, !0); let m=getProgressData(a, n, _); const v=m.segment; const w=d.segment; let P=m.segIndex; let b=d.segIndex; let M=m.i; const R=d.i; const L=b===P; const T=M===R&&L; if (p||r) {
      for (i=P<b||L&&M<R||T&&m.t<d.t, y(a, b, R, d.t)&&(b++, i||(P++, T?(m.t=(m.t-d.t)/(1-d.t), M=0):L&&(M-=R))), Math.abs(1-(n-e))<1e-5?P=b-1:!m.t&&P?P--:y(a, P, M, m.t)&&i&&b++, 1===d.t&&(b=(b+1)%a.length), u=[], f=1+(g=a.length)*r, f+=(g-(c=b)+P)%g, h=0; h<f; h++)C(u, a[c++%g]); a=u;
    } else if (l=1===m.t?6:subdivideSegment(v, M, m.t), e!==n) for (s=subdivideSegment(w, R, T?d.t/m.t:d.t), L&&(l+=s), v.splice(M+l+2), (s||R)&&w.splice(0, R+s), h=a.length; h--;)(h<b||P<h)&&a.splice(h, 1); else v.angle=getRotationAtBezierT(v, M+l, 0), d=v[M+=l], m=v[M+1], v.length=v.totalLength=0, v.totalPoints=a.totalPoints=8, v.push(d, m, d, m, d, m, d, m); return a.totalLength=0, a;
  } function measureSegment(t, e, n) {
    e=e||0, t.samples||(t.samples=[], t.lookup=[]); let r; let a; let o; let i; let s; let l; let h; let u; let g; let f; let c; let p; let d; let m; let v; let y; let x; const w=~~t.resolution||12; const P=1/w; let b=n?e+6*n+1:t.length; let M=t[e]; let R=t[e+1]; let L=e?e/6*w:0; const T=t.samples; const S=t.lookup; let C=(e?t.minLength:A)||A; let _=T[L+n*w-1]; let N=e?T[L-1]:0; for (T.length=S.length=0, a=e+2; a<b; a+=6) {
      if (o=t[a+4]-M, i=t[a+2]-M, s=t[a]-M, u=t[a+5]-R, g=t[a+3]-R, f=t[a+1]-R, l=h=c=p=0, H(o)<.01&&H(u)<.01&&H(s)+H(f)<.01)8<t.length&&(t.splice(a, 6), a-=6, b-=6); else for (r=1; r<=w; r++)l=h-(h=((m=P*r)*m*o+3*(d=1-m)*(m*i+d*s))*m), c=p-(p=(m*m*u+3*d*(m*g+d*f))*m), (y=$(c*c+l*l))<C&&(C=y), N+=y, T[L++]=N; M+=o, R+=u;
    } if (_) for (_-=N; L<T.length; L++)T[L]+=_; if (T.length&&C) {
      if (t.totalLength=x=T[T.length-1]||0, x/(t.minLength=C)<9999) for (y=v=0, r=0; r<x; r+=C)S[y++]=T[v]<r?++v:v;
    } else t.totalLength=T[0]=0; return e?N-T[e/2-1]:N;
  } function cacheRawPathMeasurements(t, e) {
    let n; let r; let a; for (a=n=r=0; a<t.length; a++)t[a].resolution=~~e||12, r+=t[a].length, n+=measureSegment(t[a]); return t.totalPoints=r, t.totalLength=n, t;
  } function subdivideSegment(t, e, n) {
    if (n<=0||1<=n) return 0; const r=t[e]; const a=t[e+1]; const o=t[e+2]; const i=t[e+3]; const s=t[e+4]; const l=t[e+5]; const h=r+(o-r)*n; let u=o+(s-o)*n; const g=a+(i-a)*n; let f=i+(l-i)*n; const c=h+(u-h)*n; const p=g+(f-g)*n; const d=s+(t[e+6]-s)*n; const m=l+(t[e+7]-l)*n; return u+=(d-u)*n, f+=(m-f)*n, t.splice(e+2, 4, N(h), N(g), N(c), N(p), N(c+(u-c)*n), N(p+(f-p)*n), N(u), N(f), N(d), N(m)), t.samples&&t.samples.splice(e/6*t.resolution|0, 0, 0, 0, 0, 0, 0, 0), 6;
  } function getProgressData(t, e, n, r) {
    n=n||{}, t.totalLength||cacheRawPathMeasurements(t), (e<0||1<e)&&(e=d(e)); let a; let o; let i; let s; let l; let h; let u; let g=0; let f=t[0]; if (e) {
      if (1===e)u=1, h=(f=t[g=t.length-1]).length-8; else {
        if (1<t.length) {
          for (i=t.totalLength*e, l=h=0; (l+=t[h++].totalLength)<i;)g=h; e=(i-(s=l-(f=t[g]).totalLength))/(l-s)||0;
        }a=f.samples, o=f.resolution, i=f.totalLength*e, s=(h=f.lookup.length?f.lookup[~~(i/f.minLength)]||0:m(a, i, e))?a[h-1]:0, (l=a[h])<i&&(s=l, l=a[++h]), u=1/o*((i-s)/(l-s)+h%o), h=6*~~(h/o), r&&1===u&&(h+6<f.length?(h+=6, u=0):g+1<t.length&&(h=u=0, f=t[++g]));
      }
    } else u=h=g=0, f=t[0]; return n.t=u, n.i=h, n.path=t, n.segment=f, n.segIndex=g, n;
  } function getPositionOnPath(t, e, n, r) {
    let a; let o; let i; let s; let l; let h; let u; let g; let f; let c=t[0]; const p=r||{}; if ((e<0||1<e)&&(e=d(e)), c.lookup||cacheRawPathMeasurements(t), 1<t.length) {
      for (i=t.totalLength*e, l=h=0; (l+=t[h++].totalLength)<i;)c=t[h]; e=(i-(s=l-c.totalLength))/(l-s)||0;
    } return a=c.samples, o=c.resolution, i=c.totalLength*e, s=(h=c.lookup.length?c.lookup[e<1?~~(i/c.minLength):c.lookup.length-1]||0:m(a, i, e))?a[h-1]:0, (l=a[h])<i&&(s=l, l=a[++h]), f=1-(u=1/o*((i-s)/(l-s)+h%o)||0), g=c[h=6*~~(h/o)], p.x=N((u*u*(c[h+6]-g)+3*f*(u*(c[h+4]-g)+f*(c[h+2]-g)))*u+g), p.y=N((u*u*(c[h+7]-(g=c[h+1]))+3*f*(u*(c[h+5]-g)+f*(c[h+3]-g)))*u+g), n&&(p.angle=c.totalLength?getRotationAtBezierT(c, h, 1<=u?1-1e-9:u||1e-9):c.angle||0), p;
  } function transformRawPath(t, e, n, r, a, o, i) {
    for (var s, l, h, u, g, f=t.length; -1<--f;) for (l=(s=t[f]).length, h=0; h<l; h+=2)u=s[h], g=s[h+1], s[h]=u*e+g*r+o, s[h+1]=u*n+g*a+i; return t._dirty=1, t;
  } function arcToSegment(t, e, n, r, a, o, i, s, l) {
    if (t!==s||e!==l) {
      n=H(n), r=H(r); const h=a%360*V; const u=U(h); const g=F(h); const f=Math.PI; const c=2*f; const p=(t-s)/2; const d=(e-l)/2; let m=u*p+g*d; let v=-g*p+u*d; const y=m*m; const x=v*v; const w=y/(n*n)+x/(r*r); 1<w&&(n=$(w)*n, r=$(w)*r); const P=n*n; const b=r*r; let M=(P*b-P*x-b*y)/(P*x+b*y); M<0&&(M=0); const R=(o===i?-1:1)*$(M); const L=n*v/r*R; const T=-r*m/n*R; const S=u*L-g*T+(t+s)/2; const C=g*L+u*T+(e+l)/2; let _=(m-L)/n; let N=(v-T)/r; const A=(-m-L)/n; const O=(-v-T)/r; const B=_*_+N*N; let I=(N<0?-1:1)*Math.acos(_/$(B)); let D=(_*O-N*A<0?-1:1)*Math.acos((_*A+N*O)/$(B*(A*A+O*O))); isNaN(D)&&(D=f), !i&&0<D?D-=c:i&&D<0&&(D+=c), I%=c, D%=c; let E; const X=Math.ceil(H(D)/(c/4)); const k=[]; const z=D/X; const G=4/3*F(z/2)/(1+U(z/2)); const Z=u*n; const q=g*n; const Y=g*-r; const j=u*r; for (E=0; E<X; E++)m=U(a=I+E*z), v=F(a), _=U(a+=z), N=F(a), k.push(m-G*v, v+G*m, _+G*N, N-G*_, _, N); for (E=0; E<k.length; E+=2)m=k[E], v=k[E+1], k[E]=m*Z+v*Y+S, k[E+1]=m*q+v*j+C; return k[E-2]=s, k[E-1]=l, k;
    }
  } function stringToRawPath(t) {
    function Cf(t, e, n, r) {
      u=(n-t)/3, g=(r-e)/3, s.push(t+u, e+g, n-u, r-g, n, r);
    } let e; let n; let r; let a; let o; let i; let s; let l; let h; let u; let g; let f; let c; let p; let d; const m=(t+'').replace(L, function(t) {
      const e=+t; return e<1e-4&&-1e-4<e?0:e;
    }).match(M)||[]; const v=[]; let y=0; let x=0; const w=m.length; let P=0; const b='ERROR: malformed path: '+t; if (!t||!isNaN(m[0])||isNaN(m[1])) return console.log(b), v; for (e=0; e<w; e++) {
      if (c=o, isNaN(m[e])?i=(o=m[e].toUpperCase())!==m[e]:e--, r=+m[e+1], a=+m[e+2], i&&(r+=y, a+=x), e||(l=r, h=a), 'M'===o)s&&(s.length<8?--v.length:P+=s.length), y=l=r, x=h=a, s=[r, a], v.push(s), e+=2, o='L'; else if ('C'===o)i||(y=x=0), (s=s||[0, 0]).push(r, a, y+1*m[e+3], x+1*m[e+4], y+=1*m[e+5], x+=1*m[e+6]), e+=6; else if ('S'===o)u=y, g=x, 'C'!==c&&'S'!==c||(u+=y-s[s.length-4], g+=x-s[s.length-3]), i||(y=x=0), s.push(u, g, r, a, y+=1*m[e+3], x+=1*m[e+4]), e+=4; else if ('Q'===o)u=y+2/3*(r-y), g=x+2/3*(a-x), i||(y=x=0), y+=1*m[e+3], x+=1*m[e+4], s.push(u, g, y+2/3*(r-y), x+2/3*(a-x), y, x), e+=4; else if ('T'===o)u=y-s[s.length-4], g=x-s[s.length-3], s.push(y+u, x+g, r+2/3*(y+1.5*u-r), a+2/3*(x+1.5*g-a), y=r, x=a), e+=2; else if ('H'===o)Cf(y, x, y=r, x), e+=1; else if ('V'===o)Cf(y, x, y, x=r+(i?x-y:0)), e+=1; else if ('L'===o||'Z'===o)'Z'===o&&(r=l, a=h, s.closed=!0), ('L'===o||.5<H(y-r)||.5<H(x-a))&&(Cf(y, x, r, a), 'L'===o&&(e+=2)), y=r, x=a; else if ('A'===o) {
        if (p=m[e+4], d=m[e+5], u=m[e+6], g=m[e+7], n=7, 1<p.length&&(p.length<3?(g=u, u=d, n--):(g=d, u=p.substr(2), n-=2), d=p.charAt(1), p=p.charAt(0)), f=arcToSegment(y, x, +m[e+1], +m[e+2], +m[e+3], +p, +d, (i?y:0)+1*u, (i?x:0)+1*g), e+=n, f) for (n=0; n<f.length; n++)s.push(f[n]); y=s[s.length-2], x=s[s.length-1];
      } else console.log(b);
    } return (e=s.length)<6?(v.pop(), e=0):s[0]===s[e-2]&&s[1]===s[e-1]&&(s.closed=!0), v.totalPoints=P+e, v;
  } function flatPointsToSegment(t, e) {
    void 0===e&&(e=1); for (var n=t[0], r=0, a=[n, r], o=2; o<t.length; o+=2)a.push(n, r, t[o], r=(t[o]-n)*e/2, n=t[o], -r); return a;
  } function pointsToSegment(t, e) {
    H(t[0]-t[2])<1e-4&&H(t[1]-t[3])<1e-4&&(t=t.slice(2)); let n; let r; let a; let o; let i; let s; let l; let h; let u; let g; let f; let c; let p; let d; let m=t.length-2; let v=+t[0]; let y=+t[1]; let x=+t[2]; let w=+t[3]; const P=[v, y, v, y]; let b=x-v; let M=w-y; const R=Math.abs(t[m]-v)<.001&&Math.abs(t[m+1]-y)<.001; for (R&&(t.push(x, w), x=v, w=y, v=t[m-2], y=t[m-1], t.unshift(v, y), m+=4), e=e||0===e?+e:1, a=2; a<m; a+=2)n=v, r=y, v=x, y=w, x=+t[a+2], w=+t[a+3], v===x&&y===w||(o=b, i=M, b=x-v, M=w-y, h=((s=$(o*o+i*i))+(l=$(b*b+M*M)))*e*.25/$(Math.pow(b/l+o/s, 2)+Math.pow(M/l+i/s, 2)), f=v-((u=v-(v-n)*(s?h/s:0))+(((g=v+(x-v)*(l?h/l:0))-u)*(3*s/(s+l)+.5)/4||0)), d=y-((c=y-(y-r)*(s?h/s:0))+(((p=y+(w-y)*(l?h/l:0))-c)*(3*s/(s+l)+.5)/4||0)), v===n&&y===r||P.push(N(u+f), N(c+d), N(v), N(y), N(g+f), N(p+d))); return v!==x||y!==w||P.length<4?P.push(N(x), N(w), N(x), N(w)):P.length-=2, 2===P.length?P.push(v, y, v, y, v, y):R&&(P.splice(0, 6), P.length=P.length-6), P;
  } function rawPathToString(t) {
    h(t[0])&&(t=[t]); let e; let n; let r; let a; let o=''; const i=t.length; for (n=0; n<i; n++) {
      for (a=t[n], o+='M'+N(a[0])+','+N(a[1])+' C', e=a.length, r=2; r<e; r++)o+=N(a[r++])+','+N(a[r++])+' '+N(a[r++])+','+N(a[r++])+' '+N(a[r++])+','+N(a[r])+' '; a.closed&&(o+='z');
    } return o;
  } function R(t) {
    let e=t.ownerDocument||t; !(k in t.style)&&'msTransform'in t.style&&(z=(k='msTransform')+'Origin'); for (;e.parentNode&&(e=e.parentNode););if (v=window, I=new Y, e) {
      w=(c=e).documentElement, P=e.body, (D=c.createElementNS('http://www.w3.org/2000/svg', 'g')).style.transform='none'; const n=e.createElement('div'); const r=e.createElement('div'); P.appendChild(n), n.appendChild(r), n.style.position='static', n.style[k]='translate3d(0,0,1px)', E=r.offsetParent!==n, P.removeChild(n);
    } return e;
  } function X(t) {
    return t.ownerSVGElement||('svg'===(t.tagName+'').toLowerCase()?t:null);
  } function Z(t, e) {
    if (t.parentNode&&(c||R(t))) {
      const n=X(t); const r=n?n.getAttribute('xmlns')||'http://www.w3.org/2000/svg':'http://www.w3.org/1999/xhtml'; const a=n?e?'rect':'g':'div'; const o=2!==e?0:100; const i=3===e?100:0; const s='position:absolute;display:block;pointer-events:none;margin:0;padding:0;'; const l=c.createElementNS?c.createElementNS(r.replace(/^https/, 'http'), a):c.createElement(a); return e&&(n?(b=b||Z(t), l.setAttribute('width', .01), l.setAttribute('height', .01), l.setAttribute('transform', 'translate('+o+','+i+')'), b.appendChild(l)):(f||((f=Z(t)).style.cssText=s), l.style.cssText=s+'width:0.1px;height:0.1px;top:'+i+'px;left:'+o+'px', f.appendChild(l))), l;
    } throw 'Need document and parent.';
  } function aa(t, e) {
    let n; let r; let a; let o; let i; let s; const l=X(t); const h=t===l; const u=l?G:q; let g=t.parentNode; if (t===v) return t; if (u.length||u.push(Z(t, 1), Z(t, 2), Z(t, 3)), n=l?b:f, l) {
h?(o=-(a=function _getCTM(t) {
  let e; let n=t.getCTM(); return n||(e=t.style[k], t.style[k]='none', t.appendChild(D), n=D.getCTM(), t.removeChild(D), e?t.style[k]=e:t.style.removeProperty(k.replace(/([A-Z])/g, '-$1').toLowerCase())), n||I.clone();
}(t)).e/a.a, i=-a.f/a.d, r=I):t.getBBox?(a=t.getBBox(), o=(r=(r=t.transform?t.transform.baseVal:{}).numberOfItems?1<r.numberOfItems?function _consolidate(t) {
  for (var e=new Y, n=0; n<t.numberOfItems; n++)e.multiply(t.getItem(n).matrix); return e;
}(r):r.getItem(0).matrix:I).a*a.x+r.c*a.y, i=r.b*a.x+r.d*a.y):(r=new Y, o=i=0), e&&'g'===t.tagName.toLowerCase()&&(o=i=0), (h?l:g).appendChild(n), n.setAttribute('transform', 'matrix('+r.a+','+r.b+','+r.c+','+r.d+','+(r.e+o)+','+(r.f+i)+')');
    } else {
      if (o=i=0, E) for (r=t.offsetParent, a=t; (a=a&&a.parentNode)&&a!==r&&a.parentNode;)4<(v.getComputedStyle(a)[k]+'').length&&(o=a.offsetLeft, i=a.offsetTop, a=0); if ('absolute'!==(s=v.getComputedStyle(t)).position&&'fixed'!==s.position) for (r=t.offsetParent; g&&g!==r;)o+=g.scrollLeft||0, i+=g.scrollTop||0, g=g.parentNode; (a=n.style).top=t.offsetTop-i+'px', a.left=t.offsetLeft-o+'px', a[k]=s[k], a[z]=s[z], a.position='fixed'===s.position?'fixed':'absolute', t.parentNode.appendChild(n);
    } return n;
  } function ba(t, e, n, r, a, o, i) {
    return t.a=e, t.b=n, t.c=r, t.d=a, t.e=o, t.f=i, t;
  } let c; let v; let w; let P; let f; let b; let I; let D; let E; let n; var k='transform'; var z=k+'Origin'; var G=[]; var q=[]; var Y=((n=Matrix2D.prototype).inverse=function inverse() {
    const t=this.a; const e=this.b; const n=this.c; const r=this.d; const a=this.e; const o=this.f; const i=t*r-e*n||1e-10; return ba(this, r/i, -e/i, -n/i, t/i, (n*o-r*a)/i, -(t*o-e*a)/i);
  }, n.multiply=function multiply(t) {
    const e=this.a; const n=this.b; const r=this.c; const a=this.d; const o=this.e; const i=this.f; const s=t.a; const l=t.c; const h=t.b; const u=t.d; const g=t.e; const f=t.f; return ba(this, s*e+h*r, s*n+h*a, l*e+u*r, l*n+u*a, o+g*e+f*r, i+g*n+f*a);
  }, n.clone=function clone() {
    return new Matrix2D(this.a, this.b, this.c, this.d, this.e, this.f);
  }, n.equals=function equals(t) {
    const e=this.a; const n=this.b; const r=this.c; const a=this.d; const o=this.e; const i=this.f; return e===t.a&&n===t.b&&r===t.c&&a===t.d&&o===t.e&&i===t.f;
  }, n.apply=function apply(t, e) {
    void 0===e&&(e={}); const n=t.x; const r=t.y; const a=this.a; const o=this.b; const i=this.c; const s=this.d; const l=this.e; const h=this.f; return e.x=n*a+r*i+l||0, e.y=n*o+r*s+h||0, e;
  }, Matrix2D); function Matrix2D(t, e, n, r, a, o) {
    void 0===t&&(t=1), void 0===e&&(e=0), void 0===n&&(n=0), void 0===r&&(r=1), void 0===a&&(a=0), void 0===o&&(o=0), ba(this, t, e, n, r, a, o);
  } function getGlobalMatrix(t, e, n, r) {
    if (!t||!t.parentNode||(c||R(t)).documentElement===t) return new Y; const a=function _forceNonZeroScale(t) {
      for (var e, n; t&&t!==P;)(n=t._gsap)&&n.uncache&&n.get(t, 'x'), n&&!n.scaleX&&!n.scaleY&&n.renderTransform&&(n.scaleX=n.scaleY=1e-4, n.renderTransform(1, n), e?e.push(n):e=[n]), t=t.parentNode; return e;
    }(t); const o=X(t)?G:q; const i=aa(t, n); let s=o[0].getBoundingClientRect(); let l=o[1].getBoundingClientRect(); const h=o[2].getBoundingClientRect(); const u=i.parentNode; const g=!r&&function _isFixed(t) {
      return 'fixed'===v.getComputedStyle(t).position||((t=t.parentNode)&&1===t.nodeType?_isFixed(t):void 0);
    }(t); const f=new Y((l.left-s.left)/100, (l.top-s.top)/100, (h.left-s.left)/100, (h.top-s.top)/100, s.left+(g?0:function _getDocScrollLeft() {
      return v.pageXOffset||c.scrollLeft||w.scrollLeft||P.scrollLeft||0;
    }()), s.top+(g?0:function _getDocScrollTop() {
      return v.pageYOffset||c.scrollTop||w.scrollTop||P.scrollTop||0;
    }())); if (u.removeChild(i), a) for (s=a.length; s--;)(l=a[s]).scaleX=l.scaleY=0, l.renderTransform(1, l); return e?f.inverse():f;
  } function na(t, e, n, r) {
    for (let a=e.length, o=2===r?0:r, i=0; i<a; i++)t[o]=parseFloat(e[i][n]), 2===r&&(t[o+1]=0), o+=2; return t;
  } function oa(t, e, n) {
    return parseFloat(t._gsap.get(t, e, n||'px'))||0;
  } function pa(t) {
    let e; let n=t[0]; let r=t[1]; for (e=2; e<t.length; e+=2)n=t[e]+=n, r=t[e+1]+=r;
  } function qa(t, e, n, r, a, o, i, s, l) {
    return e='cubic'===i.type?[e]:(!1!==i.fromCurrent&&e.unshift(oa(n, r, s), a?oa(n, a, l):0), i.relative&&pa(e), [(a?pointsToSegment:flatPointsToSegment)(e, i.curviness)]), e=o(nt(e, n, i)), rt(t, n, r, e, 'x', s), a&&rt(t, n, a, e, 'y', l), cacheRawPathMeasurements(e, i.resolution||(0===i.curviness?20:12));
  } function ra(t) {
    return t;
  } function ta(t, e, n) {
    let r; const a=getGlobalMatrix(t); let o=0; let i=0; return 'svg'===(t.tagName+'').toLowerCase()?(r=t.viewBox.baseVal).width||(r={width: +t.getAttribute('width'), height: +t.getAttribute('height')}):r=e&&t.getBBox&&t.getBBox(), e&&'auto'!==e&&(o=e.push?e[0]*(r?r.width:t.offsetWidth||0):e.x, i=e.push?e[1]*(r?r.height:t.offsetHeight||0):e.y), n.apply(o||i?a.apply({x: o, y: i}):{x: a.e, y: a.f});
  } function ua(t, e, n, r) {
    let a; const o=getGlobalMatrix(t.parentNode, !0, !0); const i=o.clone().multiply(getGlobalMatrix(e)); const s=ta(t, n, o); const l=ta(e, r, o); let h=l.x; let u=l.y; return i.e=i.f=0, 'auto'===r&&e.getTotalLength&&'path'===e.tagName.toLowerCase()&&(a=e.getAttribute('d').match(et)||[], h+=(a=i.apply({x: +a[0], y: +a[1]})).x, u+=a.y), a&&(h-=(a=i.apply(e.getBBox())).x, u-=a.y), i.e=h-s.x, i.f=u-s.y, i;
  } let j; let g; let Q; let W; let J; let o; const K='x,translateX,left,marginLeft,xPercent'.split(','); const tt='y,translateY,top,marginTop,yPercent'.split(','); const i=Math.PI/180; var et=/[-+\.]*\d+\.?(?:e-|e\+)?\d*/g; var nt=function _align(t, e, n) {
    let r; let a; let o; const i=n.align; const s=n.matrix; const l=n.offsetX; const h=n.offsetY; let u=n.alignOrigin; const g=t[0][0]; const f=t[0][1]; const c=oa(e, 'x'); const p=oa(e, 'y'); return t&&t.length?(i&&('self'===i||(r=W(i)[0]||e)===e?transformRawPath(t, 1, 0, 0, 1, c-g, p-f):(u&&!1!==u[2]?j.set(e, {transformOrigin: 100*u[0]+'% '+100*u[1]+'%'}):u=[oa(e, 'xPercent')/-100, oa(e, 'yPercent')/-100], o=(a=ua(e, r, u, 'auto')).apply({x: g, y: f}), transformRawPath(t, a.a, a.b, a.c, a.d, c+a.e-(o.x-a.e), p+a.f-(o.y-a.f)))), s?transformRawPath(t, s.a, s.b, s.c, s.d, s.e, s.f):(l||h)&&transformRawPath(t, 1, 0, 0, 1, l||0, h||0), t):getRawPath('M0,0L0,0');
  }; var rt=function _addDimensionalPropTween(t, e, n, r, a, o) {
    const i=e._gsap; const s=i.harness; const l=s&&s.aliases&&s.aliases[n]; const h=l&&l.indexOf(',')<0?l:n; const u=t._pt=new g(t._pt, e, h, 0, 0, ra, 0, i.set(e, h, t)); u.u=Q(i.get(e, h, o))||0, u.path=r, u.pp=a, t._props.push(h);
  }; const a={version: '3.12.2', name: 'motionPath', register: function register(t, e, n) {
    Q=(j=t).utils.getUnit, W=j.utils.toArray, J=j.core.getStyleSaver, o=j.core.reverting||function() {}, g=n;
  }, init: function init(t, e, n) {
    if (!j) return console.warn('Please gsap.registerPlugin(MotionPathPlugin)'), !1; 'object'==typeof e&&!e.style&&e.path||(e={path: e}); let r; let a; const o=[]; const i=e.path; const s=e.autoRotate; const l=e.unitX; const h=e.unitY; let u=e.x; let g=e.y; const f=i[0]; const c=function _sliceModifier(e, n) {
      return function(t) {
        return e||1!==n?sliceRawPath(t, e, n):t;
      };
    }(e.start, 'end'in e?e.end:1); if (this.rawPaths=o, this.target=t, this.tween=n, this.styles=J&&J(t, 'transform'), (this.rotate=s||0===s)&&(this.rOffset=parseFloat(s)||0, this.radians=!!e.useRadians, this.rProp=e.rotation||'rotation', this.rSet=t._gsap.set(t, this.rProp, this), this.ru=Q(t._gsap.get(t, this.rProp))||0), !Array.isArray(i)||'closed'in i||'number'==typeof f)cacheRawPathMeasurements(r=c(nt(getRawPath(e.path), t, e)), e.resolution), o.push(r), rt(this, t, e.x||'x', r, 'x', e.unitX||'px'), rt(this, t, e.y||'y', r, 'y', e.unitY||'px'); else {
      for (a in f)!u&&~K.indexOf(a)?u=a:!g&&~tt.indexOf(a)&&(g=a); for (a in u&&g?o.push(qa(this, na(na([], i, u, 0), i, g, 1), t, u, g, c, e, l||Q(i[0][u]), h||Q(i[0][g]))):u=g=0, f)a!==u&&a!==g&&o.push(qa(this, na([], i, a, 2), t, a, 0, c, e, Q(i[0][a])));
    }
  }, render: function render(t, e) {
    const n=e.rawPaths; let r=n.length; let a=e._pt; if (e.tween._time||!o()) {
      for (1<t?t=1:t<0&&(t=0); r--;)getPositionOnPath(n[r], t, !r&&e.rotate, n[r]); for (;a;)a.set(a.t, a.p, a.path[a.pp]+a.u, a.d, t), a=a._next; e.rotate&&e.rSet(e.target, e.rProp, n[0].angle*(e.radians?i:1)+e.rOffset+e.ru, e, t);
    } else e.styles.revert();
  }, getLength: function getLength(t) {
    return cacheRawPathMeasurements(getRawPath(t)).totalLength;
  }, sliceRawPath: sliceRawPath, getRawPath: getRawPath, pointsToSegment: pointsToSegment, stringToRawPath: stringToRawPath, rawPathToString: rawPathToString, transformRawPath: transformRawPath, getGlobalMatrix: getGlobalMatrix, getPositionOnPath: getPositionOnPath, cacheRawPathMeasurements: cacheRawPathMeasurements, convertToPath: function convertToPath$1(t, e) {
    return W(t).map(function(t) {
      return convertToPath(t, !1!==e);
    });
  }, convertCoordinates: function convertCoordinates(t, e, n) {
    const r=getGlobalMatrix(e, !0, !0).multiply(getGlobalMatrix(t)); return n?r.apply(n):r;
  }, getAlignMatrix: ua, getRelativePosition: function getRelativePosition(t, e, n, r) {
    const a=ua(t, e, n, r); return {x: a.e, y: a.f};
  }, arrayToRawPath: function arrayToRawPath(t, e) {
    const n=na(na([], t, (e=e||{}).x||'x', 0), t, e.y||'y', 1); return e.relative&&pa(n), ['cubic'===e.type?n:pointsToSegment(n, e.curviness)];
  }}; !function _getGSAP() {
    return j||'undefined'!=typeof window&&(j=window.gsap)&&j.registerPlugin&&j;
  }()||j.registerPlugin(a), t.MotionPathPlugin=a, t.default=a; if (typeof(window)==='undefined'||window!==t) {
    Object.defineProperty(t, '__esModule', {value: !0});
  } else {
    delete t.default;
  }
});

